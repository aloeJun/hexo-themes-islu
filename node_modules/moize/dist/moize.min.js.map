{"version":3,"file":"moize.min.js","sources":["../src/constants.ts","../src/utils.ts","../src/maxAge.ts","../src/stats.ts","../src/instance.ts","../src/component.ts","../src/serialize.ts","../src/options.ts","../src/maxArgs.ts","../src/index.ts","../src/updateCacheForKey.ts"],"sourcesContent":["import type { AnyFn, Options } from '../index.d';\n\n/**\n * @private\n *\n * @constant DEFAULT_OPTIONS\n */\nexport const DEFAULT_OPTIONS: Options<AnyFn> = {\n    isDeepEqual: false,\n    isPromise: false,\n    isReact: false,\n    isSerialized: false,\n    isShallowEqual: false,\n    matchesArg: undefined,\n    matchesKey: undefined,\n    maxAge: undefined,\n    maxArgs: undefined,\n    maxSize: 1,\n    onExpire: undefined,\n    profileName: undefined,\n    serializer: undefined,\n    updateCacheForKey: undefined,\n    transformArgs: undefined,\n    updateExpire: false,\n};\n","import { DEFAULT_OPTIONS } from './constants';\n\nimport type {\n    AnyFn,\n    Expiration,\n    IsEqual,\n    IsMatchingKey,\n    Key,\n    Moizeable,\n    Moized,\n    Options,\n} from '../index.d';\n\n/**\n * @private\n *\n * @description\n * method to combine functions and return a single function that fires them all\n *\n * @param functions the functions to compose\n * @returns the composed function\n */\nexport function combine<Args extends any[], Result>(\n    ...functions: Array<(...args: Args) => any>\n): ((...args: Args) => Result) | undefined {\n    return functions.reduce(function (f: any, g: any) {\n        if (typeof f === 'function') {\n            return typeof g === 'function'\n                ? function (this: any) {\n                      f.apply(this, arguments);\n                      g.apply(this, arguments);\n                  }\n                : f;\n        }\n\n        if (typeof g === 'function') {\n            return g;\n        }\n    });\n}\n\n/**\n * @private\n *\n * @description\n * method to compose functions and return a single function\n *\n * @param functions the functions to compose\n * @returns the composed function\n */\nexport function compose<Method>(...functions: Method[]): Method {\n    return functions.reduce(function (f: any, g: any) {\n        if (typeof f === 'function') {\n            return typeof g === 'function'\n                ? function (this: any) {\n                      return f(g.apply(this, arguments));\n                  }\n                : f;\n        }\n\n        if (typeof g === 'function') {\n            return g;\n        }\n    });\n}\n\n/**\n * @private\n *\n * @description\n * find the index of the expiration based on the key\n *\n * @param expirations the list of expirations\n * @param key the key to match\n * @returns the index of the expiration\n */\nexport function findExpirationIndex(expirations: Expiration[], key: Key) {\n    for (let index = 0; index < expirations.length; index++) {\n        if (expirations[index].key === key) {\n            return index;\n        }\n    }\n\n    return -1;\n}\n\n/**\n * @private\n *\n * @description\n * create function that finds the index of the key in the list of cache keys\n *\n * @param isEqual the function to test individual argument equality\n * @param isMatchingKey the function to test full key equality\n * @returns the function that finds the index of the key\n */\nexport function createFindKeyIndex(\n    isEqual: IsEqual,\n    isMatchingKey: IsMatchingKey | undefined\n) {\n    const areKeysEqual: IsMatchingKey =\n        typeof isMatchingKey === 'function'\n            ? isMatchingKey\n            : function (cacheKey: Key, key: Key) {\n                  for (let index = 0; index < key.length; index++) {\n                      if (!isEqual(cacheKey[index], key[index])) {\n                          return false;\n                      }\n                  }\n\n                  return true;\n              };\n\n    return function (keys: Key[], key: Key) {\n        for (let keysIndex = 0; keysIndex < keys.length; keysIndex++) {\n            if (\n                keys[keysIndex].length === key.length &&\n                areKeysEqual(keys[keysIndex], key)\n            ) {\n                return keysIndex;\n            }\n        }\n\n        return -1;\n    };\n}\n\ntype MergedOptions<\n    OriginalOptions extends Options<Moizeable>,\n    NewOptions extends Options<Moizeable>\n> = Omit<OriginalOptions, keyof NewOptions> & NewOptions;\n\n/**\n * @private\n *\n * @description\n * merge two options objects, combining or composing functions as necessary\n *\n * @param originalOptions the options that already exist on the method\n * @param newOptions the new options to merge\n * @returns the merged options\n */\nexport function mergeOptions<\n    OriginalOptions extends Options<Moizeable>,\n    NewOptions extends Options<Moizeable>\n>(\n    originalOptions: OriginalOptions,\n    newOptions: NewOptions | undefined\n): MergedOptions<OriginalOptions, NewOptions> {\n    if (!newOptions || newOptions === DEFAULT_OPTIONS) {\n        return originalOptions as unknown as MergedOptions<\n            OriginalOptions,\n            NewOptions\n        >;\n    }\n\n    return {\n        ...originalOptions,\n        ...newOptions,\n        onCacheAdd: combine(originalOptions.onCacheAdd, newOptions.onCacheAdd),\n        onCacheChange: combine(\n            originalOptions.onCacheChange,\n            newOptions.onCacheChange\n        ),\n        onCacheHit: combine(originalOptions.onCacheHit, newOptions.onCacheHit),\n        transformArgs: compose(\n            originalOptions.transformArgs,\n            newOptions.transformArgs\n        ),\n    };\n}\n\nexport function isMoized(\n    fn: Moizeable | Moized | Options<AnyFn>\n): fn is Moized {\n    return typeof fn === 'function' && (fn as Moizeable).isMoized;\n}\n\nexport function setName(\n    fn: Moized,\n    originalFunctionName: string,\n    profileName: string\n) {\n    try {\n        const name = profileName || originalFunctionName || 'anonymous';\n\n        Object.defineProperty(fn, 'name', {\n            configurable: true,\n            enumerable: false,\n            value: `moized(${name})`,\n            writable: true,\n        });\n    } catch {\n        // For engines where `function.name` is not configurable, do nothing.\n    }\n}\n","import { createFindKeyIndex, findExpirationIndex } from './utils';\n\nimport type {\n    AnyFn,\n    Cache,\n    Expiration,\n    IsEqual,\n    IsMatchingKey,\n    Key,\n    OnCacheOperation,\n    Options,\n} from '../index.d';\n\n/**\n * @private\n *\n * @description\n * clear an active expiration and remove it from the list if applicable\n *\n * @param expirations the list of expirations\n * @param key the key to clear\n * @param shouldRemove should the expiration be removed from the list\n */\nexport function clearExpiration(\n    expirations: Expiration[],\n    key: Key,\n    shouldRemove?: boolean\n) {\n    const expirationIndex = findExpirationIndex(expirations, key);\n\n    if (expirationIndex !== -1) {\n        clearTimeout(expirations[expirationIndex].timeoutId);\n\n        if (shouldRemove) {\n            expirations.splice(expirationIndex, 1);\n        }\n    }\n}\n\n/**\n * @private\n *\n * @description\n * Create the timeout for the given expiration method. If the ability to `unref`\n * exists, then apply it to avoid process locks in NodeJS.\n *\n * @param expirationMethod the method to fire upon expiration\n * @param maxAge the time to expire after\n * @returns the timeout ID\n */\nexport function createTimeout(expirationMethod: () => void, maxAge: number) {\n    const timeoutId = setTimeout(expirationMethod, maxAge);\n\n    if (typeof timeoutId.unref === 'function') {\n        timeoutId.unref();\n    }\n\n    return timeoutId;\n}\n\n/**\n * @private\n *\n * @description\n * create a function that, when an item is added to the cache, adds an expiration for it\n *\n * @param expirations the mutable expirations array\n * @param options the options passed on initialization\n * @param isEqual the function to check argument equality\n * @param isMatchingKey the function to check complete key equality\n * @returns the onCacheAdd function to handle expirations\n */\nexport function createOnCacheAddSetExpiration<MoizeableFn extends AnyFn>(\n    expirations: Expiration[],\n    options: Options<MoizeableFn>,\n    isEqual: IsEqual,\n    isMatchingKey: IsMatchingKey\n): OnCacheOperation<MoizeableFn> {\n    const { maxAge } = options;\n\n    return function onCacheAdd(\n        cache: Cache<MoizeableFn>,\n        moizedOptions: Options<MoizeableFn>,\n        moized: MoizeableFn\n    ) {\n        const key: any = cache.keys[0];\n\n        if (findExpirationIndex(expirations, key) === -1) {\n            const expirationMethod = function () {\n                const findKeyIndex = createFindKeyIndex(isEqual, isMatchingKey);\n\n                const keyIndex: number = findKeyIndex(cache.keys, key);\n                const value: any = cache.values[keyIndex];\n\n                if (~keyIndex) {\n                    cache.keys.splice(keyIndex, 1);\n                    cache.values.splice(keyIndex, 1);\n\n                    if (typeof options.onCacheChange === 'function') {\n                        options.onCacheChange(cache, moizedOptions, moized);\n                    }\n                }\n\n                clearExpiration(expirations, key, true);\n\n                if (\n                    typeof options.onExpire === 'function' &&\n                    options.onExpire(key) === false\n                ) {\n                    cache.keys.unshift(key);\n                    cache.values.unshift(value);\n\n                    onCacheAdd(cache, moizedOptions, moized);\n\n                    if (typeof options.onCacheChange === 'function') {\n                        options.onCacheChange(cache, moizedOptions, moized);\n                    }\n                }\n            };\n\n            expirations.push({\n                expirationMethod,\n                key,\n                timeoutId: createTimeout(expirationMethod, maxAge),\n            });\n        }\n    };\n}\n\n/**\n * @private\n *\n * @description\n * creates a function that, when a cache item is hit, reset the expiration\n *\n * @param expirations the mutable expirations array\n * @param options the options passed on initialization\n * @returns the onCacheAdd function to handle expirations\n */\nexport function createOnCacheHitResetExpiration<MoizeableFn extends AnyFn>(\n    expirations: Expiration[],\n    options: Options<MoizeableFn>\n): OnCacheOperation<MoizeableFn> {\n    return function onCacheHit(cache: Cache<MoizeableFn>) {\n        const key = cache.keys[0];\n        const expirationIndex = findExpirationIndex(expirations, key);\n\n        if (~expirationIndex) {\n            clearExpiration(expirations, key, false);\n\n            expirations[expirationIndex].timeoutId = createTimeout(\n                expirations[expirationIndex].expirationMethod,\n                options.maxAge\n            );\n        }\n    };\n}\n\n/**\n * @private\n *\n * @description\n * get the micro-memoize options specific to the maxAge option\n *\n * @param expirations the expirations for the memoized function\n * @param options the options passed to the moizer\n * @param isEqual the function to test equality of the key on a per-argument basis\n * @param isMatchingKey the function to test equality of the whole key\n * @returns the object of options based on the entries passed\n */\nexport function getMaxAgeOptions<MoizeableFn extends AnyFn>(\n    expirations: Expiration[],\n    options: Options<MoizeableFn>,\n    isEqual: IsEqual,\n    isMatchingKey: IsMatchingKey\n): {\n    onCacheAdd: OnCacheOperation<MoizeableFn> | undefined;\n    onCacheHit: OnCacheOperation<MoizeableFn> | undefined;\n} {\n    const onCacheAdd =\n        typeof options.maxAge === 'number' && isFinite(options.maxAge)\n            ? createOnCacheAddSetExpiration(\n                  expirations,\n                  options,\n                  isEqual,\n                  isMatchingKey\n              )\n            : undefined;\n\n    return {\n        onCacheAdd,\n        onCacheHit:\n            onCacheAdd && options.updateExpire\n                ? createOnCacheHitResetExpiration(expirations, options)\n                : undefined,\n    };\n}\n","import type {\n    GlobalStatsObject,\n    Moizeable,\n    OnCacheOperation,\n    Options,\n    StatsCache,\n    StatsProfile,\n} from '../index.d';\n\nexport const statsCache: StatsCache = {\n    anonymousProfileNameCounter: 1,\n    isCollectingStats: false,\n    profiles: {},\n};\n\nlet hasWarningDisplayed = false;\n\nexport function clearStats(profileName?: string) {\n    if (profileName) {\n        delete statsCache.profiles[profileName];\n    } else {\n        statsCache.profiles = {};\n    }\n}\n\n/**\n * @private\n *\n * @description\n * activate stats collection\n *\n * @param isCollectingStats should stats be collected\n */\nexport function collectStats(isCollectingStats = true) {\n    statsCache.isCollectingStats = isCollectingStats;\n}\n\n/**\n * @private\n *\n * @description\n * create a function that increments the number of calls for the specific profile\n */\nexport function createOnCacheAddIncrementCalls<MoizeableFn extends Moizeable>(\n    options: Options<MoizeableFn>\n) {\n    const { profileName } = options;\n\n    return function () {\n        if (profileName && !statsCache.profiles[profileName]) {\n            statsCache.profiles[profileName] = {\n                calls: 0,\n                hits: 0,\n            };\n        }\n\n        statsCache.profiles[profileName].calls++;\n    };\n}\n\n/**\n * @private\n *\n * @description\n * create a function that increments the number of calls and cache hits for the specific profile\n */\nexport function createOnCacheHitIncrementCallsAndHits<\n    MoizeableFn extends Moizeable\n>(options: Options<MoizeableFn>) {\n    return function () {\n        const { profiles } = statsCache;\n        const { profileName } = options;\n\n        if (!profiles[profileName]) {\n            profiles[profileName] = {\n                calls: 0,\n                hits: 0,\n            };\n        }\n\n        profiles[profileName].calls++;\n        profiles[profileName].hits++;\n    };\n}\n\n/**\n * @private\n *\n * @description\n * get the profileName for the function when one is not provided\n *\n * @param fn the function to be memoized\n * @returns the derived profileName for the function\n */\nexport function getDefaultProfileName<MoizeableFn extends Moizeable>(\n    fn: MoizeableFn\n) {\n    return (\n        fn.displayName ||\n        fn.name ||\n        `Anonymous ${statsCache.anonymousProfileNameCounter++}`\n    );\n}\n\n/**\n * @private\n *\n * @description\n * get the usage percentage based on the number of hits and total calls\n *\n * @param calls the number of calls made\n * @param hits the number of cache hits when called\n * @returns the usage as a percentage string\n */\nexport function getUsagePercentage(calls: number, hits: number) {\n    return calls ? `${((hits / calls) * 100).toFixed(4)}%` : '0.0000%';\n}\n\n/**\n * @private\n *\n * @description\n * get the statistics for a given method or all methods\n *\n * @param [profileName] the profileName to get the statistics for (get all when not provided)\n * @returns the object with stats information\n */\nexport function getStats(profileName?: string): GlobalStatsObject {\n    if (!statsCache.isCollectingStats && !hasWarningDisplayed) {\n        console.warn(\n            'Stats are not currently being collected, please run \"collectStats\" to enable them.'\n        ); // eslint-disable-line no-console\n\n        hasWarningDisplayed = true;\n    }\n\n    const { profiles } = statsCache;\n\n    if (profileName) {\n        if (!profiles[profileName]) {\n            return {\n                calls: 0,\n                hits: 0,\n                usage: '0.0000%',\n            };\n        }\n\n        const { [profileName]: profile } = profiles;\n\n        return {\n            ...profile,\n            usage: getUsagePercentage(profile.calls, profile.hits),\n        };\n    }\n\n    const completeStats: StatsProfile = Object.keys(statsCache.profiles).reduce(\n        (completeProfiles, profileName) => {\n            completeProfiles.calls += profiles[profileName].calls;\n            completeProfiles.hits += profiles[profileName].hits;\n\n            return completeProfiles;\n        },\n        {\n            calls: 0,\n            hits: 0,\n        }\n    );\n\n    return {\n        ...completeStats,\n        profiles: Object.keys(profiles).reduce(\n            (computedProfiles, profileName) => {\n                computedProfiles[profileName] = getStats(profileName);\n\n                return computedProfiles;\n            },\n            {} as Record<string, StatsProfile>\n        ),\n        usage: getUsagePercentage(completeStats.calls, completeStats.hits),\n    };\n}\n\n/**\n * @private\n *\n * @function getStatsOptions\n *\n * @description\n * get the options specific to storing statistics\n *\n * @param {Options} options the options passed to the moizer\n * @returns {Object} the options specific to keeping stats\n */\nexport function getStatsOptions<MoizeableFn extends Moizeable>(\n    options: Options<MoizeableFn>\n): {\n    onCacheAdd?: OnCacheOperation<MoizeableFn>;\n    onCacheHit?: OnCacheOperation<MoizeableFn>;\n} {\n    return statsCache.isCollectingStats\n        ? {\n              onCacheAdd: createOnCacheAddIncrementCalls(options),\n              onCacheHit: createOnCacheHitIncrementCallsAndHits(options),\n          }\n        : {};\n}\n","import { clearExpiration } from './maxAge';\nimport { clearStats, getStats } from './stats';\nimport { createFindKeyIndex } from './utils';\n\nimport type {\n    Key,\n    Memoized,\n    Moizeable,\n    MoizeConfiguration,\n    Moized,\n    Options,\n    StatsProfile,\n} from '../index.d';\n\nconst ALWAYS_SKIPPED_PROPERTIES: Record<string, boolean> = {\n    arguments: true,\n    callee: true,\n    caller: true,\n    constructor: true,\n    length: true,\n    name: true,\n    prototype: true,\n};\n\n/**\n * @private\n *\n * @description\n * copy the static properties from the original function to the moized\n * function\n *\n * @param originalFn the function copying from\n * @param newFn the function copying to\n * @param skippedProperties the list of skipped properties, if any\n */\nexport function copyStaticProperties<\n    OriginalMoizeableFn extends Moizeable,\n    NewMoizeableFn extends Moizeable\n>(\n    originalFn: OriginalMoizeableFn,\n    newFn: NewMoizeableFn,\n    skippedProperties: string[] = []\n) {\n    Object.getOwnPropertyNames(originalFn).forEach((property) => {\n        if (\n            !ALWAYS_SKIPPED_PROPERTIES[property] &&\n            skippedProperties.indexOf(property) === -1\n        ) {\n            const descriptor = Object.getOwnPropertyDescriptor(\n                originalFn,\n                property\n            );\n\n            if (descriptor.get || descriptor.set) {\n                Object.defineProperty(newFn, property, descriptor);\n            } else {\n                // @ts-expect-error - properites may not align\n                newFn[property] = originalFn[property];\n            }\n        }\n    });\n}\n\n/**\n * @private\n *\n * @description\n * add methods to the moized fuction object that allow extra features\n *\n * @param memoized the memoized function from micro-memoize\n */\nexport function addInstanceMethods<MoizeableFn extends Moizeable>(\n    memoized: Moizeable,\n    { expirations }: MoizeConfiguration<MoizeableFn>\n) {\n    const { options } = memoized;\n\n    const findKeyIndex = createFindKeyIndex(\n        options.isEqual,\n        options.isMatchingKey\n    );\n\n    const moized = memoized as unknown as Moized<\n        MoizeableFn,\n        Options<MoizeableFn>\n    >;\n\n    moized.clear = function () {\n        const {\n            _microMemoizeOptions: { onCacheChange },\n            cache,\n        } = moized;\n\n        cache.keys.length = 0;\n        cache.values.length = 0;\n\n        if (onCacheChange) {\n            onCacheChange(cache, moized.options, moized);\n        }\n\n        return true;\n    };\n\n    moized.clearStats = function () {\n        clearStats(moized.options.profileName);\n    };\n\n    moized.get = function (key: Key) {\n        const {\n            _microMemoizeOptions: { transformKey },\n            cache,\n        } = moized;\n\n        const cacheKey = transformKey ? transformKey(key) : key;\n        const keyIndex = findKeyIndex(cache.keys, cacheKey);\n\n        return keyIndex !== -1 ? moized.apply(this, key) : undefined;\n    };\n\n    moized.getStats = function (): StatsProfile {\n        return getStats(moized.options.profileName);\n    };\n\n    moized.has = function (key: Key) {\n        const { transformKey } = moized._microMemoizeOptions;\n\n        const cacheKey = transformKey ? transformKey(key) : key;\n\n        return findKeyIndex(moized.cache.keys, cacheKey) !== -1;\n    };\n\n    moized.keys = function () {\n        return moized.cacheSnapshot.keys;\n    };\n\n    moized.remove = function (key: Key) {\n        const {\n            _microMemoizeOptions: { onCacheChange, transformKey },\n            cache,\n        } = moized;\n\n        const keyIndex = findKeyIndex(\n            cache.keys,\n            transformKey ? transformKey(key) : key\n        );\n\n        if (keyIndex === -1) {\n            return false;\n        }\n\n        const existingKey = cache.keys[keyIndex];\n\n        cache.keys.splice(keyIndex, 1);\n        cache.values.splice(keyIndex, 1);\n\n        if (onCacheChange) {\n            onCacheChange(cache, moized.options, moized);\n        }\n\n        clearExpiration(expirations, existingKey, true);\n\n        return true;\n    };\n\n    moized.set = function (key: Key, value: any) {\n        const { _microMemoizeOptions, cache, options } = moized;\n        const { onCacheAdd, onCacheChange, transformKey } =\n            _microMemoizeOptions;\n\n        const cacheKey = transformKey ? transformKey(key) : key;\n        const keyIndex = findKeyIndex(cache.keys, cacheKey);\n\n        if (keyIndex === -1) {\n            const cutoff = options.maxSize - 1;\n\n            if (cache.size > cutoff) {\n                cache.keys.length = cutoff;\n                cache.values.length = cutoff;\n            }\n\n            cache.keys.unshift(cacheKey);\n            cache.values.unshift(value);\n\n            if (options.isPromise) {\n                cache.updateAsyncCache(moized);\n            }\n\n            if (onCacheAdd) {\n                onCacheAdd(cache, options, moized);\n            }\n\n            if (onCacheChange) {\n                onCacheChange(cache, options, moized);\n            }\n        } else {\n            const existingKey = cache.keys[keyIndex];\n\n            cache.values[keyIndex] = value;\n\n            if (keyIndex > 0) {\n                cache.orderByLru(existingKey, value, keyIndex);\n            }\n\n            if (options.isPromise) {\n                cache.updateAsyncCache(moized);\n            }\n\n            if (typeof onCacheChange === 'function') {\n                onCacheChange(cache, options, moized);\n            }\n        }\n    };\n\n    moized.values = function () {\n        return moized.cacheSnapshot.values;\n    };\n}\n\n/**\n * @private\n *\n * @description\n * add propeties to the moized fuction object that surfaces extra information\n *\n * @param memoized the memoized function\n * @param expirations the list of expirations for cache items\n * @param options the options passed to the moizer\n * @param originalFunction the function that is being memoized\n */\nexport function addInstanceProperties<MoizeableFn extends Moizeable>(\n    memoized: Memoized<MoizeableFn>,\n    {\n        expirations,\n        options: moizeOptions,\n        originalFunction,\n    }: MoizeConfiguration<MoizeableFn>\n) {\n    const { options: microMemoizeOptions } = memoized;\n\n    Object.defineProperties(memoized, {\n        _microMemoizeOptions: {\n            configurable: true,\n            get() {\n                return microMemoizeOptions;\n            },\n        },\n\n        cacheSnapshot: {\n            configurable: true,\n            get() {\n                const { cache: currentCache } = memoized;\n\n                return {\n                    keys: currentCache.keys.slice(0),\n                    size: currentCache.size,\n                    values: currentCache.values.slice(0),\n                };\n            },\n        },\n\n        expirations: {\n            configurable: true,\n            get() {\n                return expirations;\n            },\n        },\n\n        expirationsSnapshot: {\n            configurable: true,\n            get() {\n                return expirations.slice(0);\n            },\n        },\n\n        isMoized: {\n            configurable: true,\n            get() {\n                return true;\n            },\n        },\n\n        options: {\n            configurable: true,\n            get() {\n                return moizeOptions;\n            },\n        },\n\n        originalFunction: {\n            configurable: true,\n            get() {\n                return originalFunction;\n            },\n        },\n    });\n\n    const moized = memoized as unknown as Moized<\n        MoizeableFn,\n        Options<MoizeableFn>\n    >;\n\n    copyStaticProperties(originalFunction, moized);\n}\n\n/**\n * @private\n *\n * @description\n * add methods and properties to the memoized function for more features\n *\n * @param memoized the memoized function\n * @param configuration the configuration object for the instance\n * @returns the memoized function passed\n */\nexport function createMoizeInstance<\n    MoizeableFn extends Moizeable,\n    CombinedOptions extends Options<MoizeableFn>\n>(\n    memoized: Memoized<MoizeableFn>,\n    configuration: MoizeConfiguration<MoizeableFn>\n) {\n    addInstanceMethods<MoizeableFn>(memoized, configuration);\n    addInstanceProperties<MoizeableFn>(memoized, configuration);\n\n    return memoized as Moized<MoizeableFn, CombinedOptions>;\n}\n","import { copyStaticProperties } from './instance';\nimport { setName } from './utils';\n\nimport type {\n    Moize,\n    Moized as MoizedFunction,\n    Moizeable,\n    Options,\n} from '../index.d';\n\n// This was stolen from React internals, which allows us to create React elements without needing\n// a dependency on the React library itself.\nconst REACT_ELEMENT_TYPE =\n    typeof Symbol === 'function' && Symbol.for\n        ? Symbol.for('react.element')\n        : 0xeac7;\n\n/**\n * @private\n *\n * @description\n * Create a component that memoizes based on `props` and legacy `context`\n * on a per-instance basis. This requires creating a component class to\n * store the memoized function. The cost is quite low, and avoids the\n * need to have access to the React dependency by basically re-creating\n * the basic essentials for a component class and the results of the\n * `createElement` function.\n *\n * @param moizer the top-level moize method\n * @param fn the component to memoize\n * @param options the memoization options\n * @returns the memoized component\n */\nexport function createMoizedComponent<MoizeableFn extends Moizeable>(\n    moizer: Moize,\n    fn: MoizeableFn,\n    options: Options<MoizeableFn>\n) {\n    /**\n     * This is a hack override setting the necessary options\n     * for a React component to be memoized. In the main `moize`\n     * method, if the `isReact` option is set it is short-circuited\n     * to call this function, and these overrides allow the\n     * necessary transformKey method to be derived.\n     *\n     * The order is based on:\n     * 1) Set the necessary aspects of transformKey for React components.\n     * 2) Allow setting of other options and overrides of those aspects\n     *    if desired (for example, `isDeepEqual` will use deep equality).\n     * 3) Always set `isReact` to false to prevent infinite loop.\n     */\n    const reactMoizer = moizer({\n        maxArgs: 2,\n        isShallowEqual: true,\n        ...options,\n        isReact: false,\n    });\n\n    if (!fn.displayName) {\n        // @ts-ignore - allow setting of displayName\n        fn.displayName = fn.name || 'Component';\n    }\n\n    function Moized<Props extends Record<string, unknown>, Context, Updater>(\n        this: any,\n        props: Props,\n        context: Context,\n        updater: Updater\n    ) {\n        this.props = props;\n        this.context = context;\n        this.updater = updater;\n\n        this.MoizedComponent = reactMoizer(fn);\n    }\n\n    Moized.prototype.isReactComponent = {};\n\n    Moized.prototype.render = function (): ReturnType<MoizeableFn> {\n        return {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: this.MoizedComponent,\n            props: this.props,\n            ref: null,\n            key: null,\n            _owner: null,\n        } as ReturnType<MoizeableFn>;\n    };\n\n    copyStaticProperties(fn, Moized, ['contextType', 'contextTypes']);\n\n    Moized.displayName = `Moized(${fn.displayName || fn.name || 'Component'})`;\n\n    setName(Moized as MoizedFunction, fn.name, options.profileName);\n\n    return Moized;\n}\n","import type { Key, Moizeable, Options } from '../index.d';\n\n/**\n * @function getCutoff\n *\n * @description\n * faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\nfunction getCutoff(array: any[], value: any) {\n    const { length } = array;\n\n    for (let index = 0; index < length; ++index) {\n        if (array[index] === value) {\n            return index + 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @private\n *\n * @description\n * custom replacer for the stringify function\n *\n * @returns if function then toString of it, else the value itself\n */\nexport function createDefaultReplacer() {\n    const cache: any[] = [];\n    const keys: string[] = [];\n\n    return function defaultReplacer(key: string, value: any) {\n        const type = typeof value;\n\n        if (type === 'function' || type === 'symbol') {\n            return value.toString();\n        }\n\n        if (typeof value === 'object') {\n            if (cache.length) {\n                const thisCutoff = getCutoff(cache, this);\n\n                if (thisCutoff === 0) {\n                    cache[cache.length] = this;\n                } else {\n                    cache.splice(thisCutoff);\n                    keys.splice(thisCutoff);\n                }\n\n                keys[keys.length] = key;\n\n                const valueCutoff = getCutoff(cache, value);\n\n                if (valueCutoff !== 0) {\n                    return `[ref=${\n                        keys.slice(0, valueCutoff).join('.') || '.'\n                    }]`;\n                }\n            } else {\n                cache[0] = value;\n                keys[0] = key;\n            }\n\n            return value;\n        }\n\n        return '' + value;\n    };\n}\n\n/**\n * @private\n *\n * @description\n * get the stringified version of the argument passed\n *\n * @param arg argument to stringify\n * @returns the stringified argument\n */\nexport function getStringifiedArgument<Type>(arg: Type) {\n    const typeOfArg = typeof arg;\n\n    return arg && (typeOfArg === 'object' || typeOfArg === 'function')\n        ? JSON.stringify(arg, createDefaultReplacer())\n        : arg;\n}\n\n/**\n * @private\n *\n * @description\n * serialize the arguments passed\n *\n * @param options the options passed to the moizer\n * @param options.maxArgs the cap on the number of arguments used in serialization\n * @returns argument serialization method\n */\nexport function defaultArgumentSerializer(args: Key) {\n    let key = '|';\n\n    for (let index = 0; index < args.length; index++) {\n        key += getStringifiedArgument(args[index]) + '|';\n    }\n\n    return [key];\n}\n\n/**\n * @private\n *\n * @description\n * based on the options passed, either use the serializer passed or generate the internal one\n *\n * @param options the options passed to the moized function\n * @returns the function to use in serializing the arguments\n */\nexport function getSerializerFunction<MoizeableFn extends Moizeable>(\n    options: Options<MoizeableFn>\n) {\n    return typeof options.serializer === 'function'\n        ? options.serializer\n        : defaultArgumentSerializer;\n}\n\n/**\n * @private\n *\n * @description\n * are the serialized keys equal to one another\n *\n * @param cacheKey the cache key to compare\n * @param key the key to test\n * @returns are the keys equal\n */\nexport function getIsSerializedKeyEqual(cacheKey: Key, key: Key) {\n    return cacheKey[0] === key[0];\n}\n","import { deepEqual, sameValueZeroEqual, shallowEqual } from 'fast-equals';\nimport { createGetInitialArgs } from './maxArgs';\nimport { getIsSerializedKeyEqual, getSerializerFunction } from './serialize';\nimport { compose } from './utils';\n\nimport type {\n    Cache,\n    IsEqual,\n    IsMatchingKey,\n    MicroMemoizeOptions,\n    Moizeable,\n    Moized,\n    OnCacheOperation,\n    Options,\n    TransformKey,\n} from '../index.d';\n\nexport function createOnCacheOperation<MoizeableFn extends Moizeable>(\n    fn?: OnCacheOperation<MoizeableFn>\n): OnCacheOperation<MoizeableFn> {\n    if (typeof fn === 'function') {\n        return (\n            _cacheIgnored: Cache<MoizeableFn>,\n            _microMemoizeOptionsIgnored: MicroMemoizeOptions<MoizeableFn>,\n            memoized: Moized\n        ): void => fn(memoized.cache, memoized.options, memoized);\n    }\n}\n\n/**\n * @private\n *\n * @description\n * get the isEqual method passed to micro-memoize\n *\n * @param options the options passed to the moizer\n * @returns the isEqual method to apply\n */\nexport function getIsEqual<MoizeableFn extends Moizeable>(\n    options: Options<MoizeableFn>\n): IsEqual {\n    return (\n        options.matchesArg ||\n        (options.isDeepEqual && deepEqual) ||\n        (options.isShallowEqual && shallowEqual) ||\n        sameValueZeroEqual\n    );\n}\n\n/**\n * @private\n *\n * @description\n * get the isEqual method passed to micro-memoize\n *\n * @param options the options passed to the moizer\n * @returns the isEqual method to apply\n */\nexport function getIsMatchingKey<MoizeableFn extends Moizeable>(\n    options: Options<MoizeableFn>\n): IsMatchingKey | undefined {\n    return (\n        options.matchesKey ||\n        (options.isSerialized && getIsSerializedKeyEqual) ||\n        undefined\n    );\n}\n\n/**\n * @private\n *\n * @description\n * get the function that will transform the key based on the arguments passed\n *\n * @param options the options passed to the moizer\n * @returns the function to transform the key with\n */\nexport function getTransformKey<MoizeableFn extends Moizeable>(\n    options: Options<MoizeableFn>\n): TransformKey | undefined {\n    return compose(\n        options.isSerialized && getSerializerFunction(options),\n        typeof options.transformArgs === 'function' && options.transformArgs,\n        typeof options.maxArgs === 'number' &&\n            createGetInitialArgs(options.maxArgs)\n    ) as TransformKey;\n}\n","import type { Key } from '../index.d';\n\nexport function createGetInitialArgs(size: number) {\n    /**\n     * @private\n     *\n     * @description\n     * take the first N number of items from the array (faster than slice)\n     *\n     * @param args the args to take from\n     * @returns the shortened list of args as an array\n     */\n    return function (args: Key): Key {\n        if (size >= args.length) {\n            return args;\n        }\n\n        if (size === 0) {\n            return [];\n        }\n\n        if (size === 1) {\n            return [args[0]];\n        }\n\n        if (size === 2) {\n            return [args[0], args[1]];\n        }\n\n        if (size === 3) {\n            return [args[0], args[1], args[2]];\n        }\n\n        const clone = [];\n\n        for (let index = 0; index < size; index++) {\n            clone[index] = args[index];\n        }\n\n        return clone;\n    };\n}\n","import memoize from 'micro-memoize';\nimport { createMoizedComponent } from './component';\nimport { DEFAULT_OPTIONS } from './constants';\nimport { createMoizeInstance } from './instance';\nimport { getMaxAgeOptions } from './maxAge';\nimport {\n    createOnCacheOperation,\n    getIsEqual,\n    getIsMatchingKey,\n    getTransformKey,\n} from './options';\nimport {\n    clearStats,\n    collectStats,\n    getDefaultProfileName,\n    getStats,\n    getStatsOptions,\n    statsCache,\n} from './stats';\nimport { createRefreshableMoized } from './updateCacheForKey';\nimport { combine, compose, isMoized, mergeOptions, setName } from './utils';\n\nimport type {\n    Expiration,\n    IsEqual,\n    IsMatchingKey,\n    MicroMemoizeOptions,\n    Moize,\n    Moizeable,\n    Moized,\n    OnExpire,\n    Options,\n    Serialize,\n    TransformKey,\n    UpdateCacheForKey,\n} from '../index.d';\n\n/**\n * @module moize\n */\n\n/**\n * @description\n * memoize a function based its arguments passed, potentially improving runtime performance\n *\n * @example\n * import moize from 'moize';\n *\n * // standard implementation\n * const fn = (foo, bar) => `${foo} ${bar}`;\n * const memoizedFn = moize(fn);\n *\n * // implementation with options\n * const fn = async (id) => get(`http://foo.com/${id}`);\n * const memoizedFn = moize(fn, {isPromise: true, maxSize: 5});\n *\n * // implementation with convenience methods\n * const Foo = ({foo}) => <div>{foo}</div>;\n * const MemoizedFoo = moize.react(Foo);\n *\n * @param fn the function to memoized, or a list of options when currying\n * @param [options=DEFAULT_OPTIONS] the options to apply\n * @returns the memoized function\n */\nconst moize: Moize = function <\n    MoizeableFn extends Moizeable,\n    PassedOptions extends Options<MoizeableFn>\n>(fn: MoizeableFn | PassedOptions, passedOptions?: PassedOptions) {\n    type CombinedOptions = Omit<Options<MoizeableFn>, keyof PassedOptions> &\n        PassedOptions;\n\n    const options: Options<MoizeableFn> = passedOptions || DEFAULT_OPTIONS;\n\n    if (isMoized(fn)) {\n        const moizeable = fn.originalFunction as MoizeableFn;\n        const mergedOptions = mergeOptions(\n            fn.options,\n            options\n        ) as CombinedOptions;\n\n        return moize<MoizeableFn, CombinedOptions>(moizeable, mergedOptions);\n    }\n\n    if (typeof fn === 'object') {\n        return function <\n            CurriedFn extends Moizeable,\n            CurriedOptions extends Options<CurriedFn>\n        >(\n            curriedFn: CurriedFn | CurriedOptions,\n            curriedOptions: CurriedOptions\n        ) {\n            type CombinedCurriedOptions = Omit<\n                CombinedOptions,\n                keyof CurriedOptions\n            > &\n                CurriedOptions;\n\n            if (typeof curriedFn === 'function') {\n                const mergedOptions = mergeOptions(\n                    fn as CombinedOptions,\n                    curriedOptions\n                ) as CombinedCurriedOptions;\n\n                return moize(curriedFn, mergedOptions);\n            }\n\n            const mergedOptions = mergeOptions(\n                fn as CombinedOptions,\n                curriedFn as CurriedOptions\n            );\n\n            return moize(mergedOptions);\n        };\n    }\n\n    if (options.isReact) {\n        return createMoizedComponent(moize, fn, options);\n    }\n\n    const coalescedOptions: Options<MoizeableFn> = {\n        ...DEFAULT_OPTIONS,\n        ...options,\n        maxAge:\n            typeof options.maxAge === 'number' && options.maxAge >= 0\n                ? options.maxAge\n                : DEFAULT_OPTIONS.maxAge,\n        maxArgs:\n            typeof options.maxArgs === 'number' && options.maxArgs >= 0\n                ? options.maxArgs\n                : DEFAULT_OPTIONS.maxArgs,\n        maxSize:\n            typeof options.maxSize === 'number' && options.maxSize >= 0\n                ? options.maxSize\n                : DEFAULT_OPTIONS.maxSize,\n        profileName: options.profileName || getDefaultProfileName(fn),\n    };\n    const expirations: Array<Expiration> = [];\n\n    const {\n        matchesArg: equalsIgnored,\n        isDeepEqual: isDeepEqualIgnored,\n        isPromise,\n        isReact: isReactIgnored,\n        isSerialized: isSerialzedIgnored,\n        isShallowEqual: isShallowEqualIgnored,\n        matchesKey: matchesKeyIgnored,\n        maxAge: maxAgeIgnored,\n        maxArgs: maxArgsIgnored,\n        maxSize,\n        onCacheAdd,\n        onCacheChange,\n        onCacheHit,\n        onExpire: onExpireIgnored,\n        profileName: profileNameIgnored,\n        serializer: serializerIgnored,\n        updateCacheForKey,\n        transformArgs: transformArgsIgnored,\n        updateExpire: updateExpireIgnored,\n        ...customOptions\n    } = coalescedOptions;\n\n    const isEqual = getIsEqual(coalescedOptions);\n    const isMatchingKey = getIsMatchingKey(coalescedOptions);\n\n    const maxAgeOptions = getMaxAgeOptions(\n        expirations,\n        coalescedOptions,\n        isEqual,\n        isMatchingKey\n    );\n    const statsOptions = getStatsOptions(coalescedOptions);\n\n    const transformKey = getTransformKey(coalescedOptions);\n\n    const microMemoizeOptions: MicroMemoizeOptions<MoizeableFn> = {\n        ...customOptions,\n        isEqual,\n        isMatchingKey,\n        isPromise,\n        maxSize,\n        onCacheAdd: createOnCacheOperation(\n            combine(\n                onCacheAdd,\n                maxAgeOptions.onCacheAdd,\n                statsOptions.onCacheAdd\n            )\n        ),\n        onCacheChange: createOnCacheOperation(onCacheChange),\n        onCacheHit: createOnCacheOperation(\n            combine(\n                onCacheHit,\n                maxAgeOptions.onCacheHit,\n                statsOptions.onCacheHit\n            )\n        ),\n        transformKey,\n    };\n\n    const memoized = memoize(fn, microMemoizeOptions);\n\n    let moized = createMoizeInstance<MoizeableFn, CombinedOptions>(memoized, {\n        expirations,\n        options: coalescedOptions,\n        originalFunction: fn,\n    });\n\n    if (updateCacheForKey) {\n        moized = createRefreshableMoized<typeof moized>(moized);\n    }\n\n    setName(moized, (fn as Moizeable).name, options.profileName);\n\n    return moized;\n};\n\n/**\n * @function\n * @name clearStats\n * @memberof module:moize\n * @alias moize.clearStats\n *\n * @description\n * clear all existing stats stored\n */\nmoize.clearStats = clearStats;\n\n/**\n * @function\n * @name collectStats\n * @memberof module:moize\n * @alias moize.collectStats\n *\n * @description\n * start collecting statistics\n */\nmoize.collectStats = collectStats;\n\n/**\n * @function\n * @name compose\n * @memberof module:moize\n * @alias moize.compose\n *\n * @description\n * method to compose moized methods and return a single moized function\n *\n * @param moized the functions to compose\n * @returns the composed function\n */\nmoize.compose = function (...moized: Moize[]) {\n    return compose<Moize>(...moized) || moize;\n};\n\n/**\n * @function\n * @name deep\n * @memberof module:moize\n * @alias moize.deep\n *\n * @description\n * should deep equality check be used\n *\n * @returns the moizer function\n */\nmoize.deep = moize({ isDeepEqual: true });\n\n/**\n * @function\n * @name getStats\n * @memberof module:moize\n * @alias moize.getStats\n *\n * @description\n * get the statistics of a given profile, or overall usage\n *\n * @returns statistics for a given profile or overall usage\n */\nmoize.getStats = getStats;\n\n/**\n * @function\n * @name infinite\n * @memberof module:moize\n * @alias moize.infinite\n *\n * @description\n * a moized method that will remove all limits from the cache size\n *\n * @returns the moizer function\n */\nmoize.infinite = moize({ maxSize: Infinity });\n\n/**\n * @function\n * @name isCollectingStats\n * @memberof module:moize\n * @alias moize.isCollectingStats\n *\n * @description\n * are stats being collected\n *\n * @returns are stats being collected\n */\nmoize.isCollectingStats = function isCollectingStats(): boolean {\n    return statsCache.isCollectingStats;\n};\n\n/**\n * @function\n * @name isMoized\n * @memberof module:moize\n * @alias moize.isMoized\n *\n * @description\n * is the fn passed a moized function\n *\n * @param fn the object to test\n * @returns is fn a moized function\n */\nmoize.isMoized = function isMoized(fn: any): fn is Moized {\n    return typeof fn === 'function' && !!fn.isMoized;\n};\n\n/**\n * @function\n * @name matchesArg\n * @memberof module:moize\n * @alias moize.matchesArg\n *\n * @description\n * a moized method where the arg matching method is the custom one passed\n *\n * @param keyMatcher the method to compare against those in cache\n * @returns the moizer function\n */\nmoize.matchesArg = function (argMatcher: IsEqual) {\n    return moize({ matchesArg: argMatcher });\n};\n\n/**\n * @function\n * @name matchesKey\n * @memberof module:moize\n * @alias moize.matchesKey\n *\n * @description\n * a moized method where the key matching method is the custom one passed\n *\n * @param keyMatcher the method to compare against those in cache\n * @returns the moizer function\n */\nmoize.matchesKey = function (keyMatcher: IsMatchingKey) {\n    return moize({ matchesKey: keyMatcher });\n};\n\nfunction maxAge<MaxAge extends number>(\n    maxAge: MaxAge\n): Moize<{ maxAge: MaxAge }>;\nfunction maxAge<MaxAge extends number, UpdateExpire extends boolean>(\n    maxAge: MaxAge,\n    expireOptions: UpdateExpire\n): Moize<{ maxAge: MaxAge; updateExpire: UpdateExpire }>;\nfunction maxAge<MaxAge extends number, ExpireHandler extends OnExpire>(\n    maxAge: MaxAge,\n    expireOptions: ExpireHandler\n): Moize<{ maxAge: MaxAge; onExpire: ExpireHandler }>;\nfunction maxAge<\n    MaxAge extends number,\n    ExpireHandler extends OnExpire,\n    ExpireOptions extends {\n        onExpire: ExpireHandler;\n    }\n>(\n    maxAge: MaxAge,\n    expireOptions: ExpireOptions\n): Moize<{ maxAge: MaxAge; onExpire: ExpireOptions['onExpire'] }>;\nfunction maxAge<\n    MaxAge extends number,\n    UpdateExpire extends boolean,\n    ExpireOptions extends {\n        updateExpire: UpdateExpire;\n    }\n>(\n    maxAge: MaxAge,\n    expireOptions: ExpireOptions\n): Moize<{ maxAge: MaxAge; updateExpire: UpdateExpire }>;\nfunction maxAge<\n    MaxAge extends number,\n    ExpireHandler extends OnExpire,\n    UpdateExpire extends boolean,\n    ExpireOptions extends {\n        onExpire: ExpireHandler;\n        updateExpire: UpdateExpire;\n    }\n>(\n    maxAge: MaxAge,\n    expireOptions: ExpireOptions\n): Moize<{\n    maxAge: MaxAge;\n    onExpire: ExpireHandler;\n    updateExpire: UpdateExpire;\n}>;\nfunction maxAge<\n    MaxAge extends number,\n    ExpireHandler extends OnExpire,\n    UpdateExpire extends boolean,\n    ExpireOptions extends {\n        onExpire?: ExpireHandler;\n        updateExpire?: UpdateExpire;\n    }\n>(\n    maxAge: MaxAge,\n    expireOptions?: ExpireHandler | UpdateExpire | ExpireOptions\n) {\n    if (expireOptions === true) {\n        return moize({\n            maxAge,\n            updateExpire: expireOptions,\n        });\n    }\n\n    if (typeof expireOptions === 'object') {\n        const { onExpire, updateExpire } = expireOptions;\n\n        return moize({\n            maxAge,\n            onExpire,\n            updateExpire,\n        });\n    }\n\n    if (typeof expireOptions === 'function') {\n        return moize({\n            maxAge,\n            onExpire: expireOptions,\n            updateExpire: true,\n        });\n    }\n\n    return moize({ maxAge });\n}\n\n/**\n * @function\n * @name maxAge\n * @memberof module:moize\n * @alias moize.maxAge\n *\n * @description\n * a moized method where the age of the cache is limited to the number of milliseconds passed\n *\n * @param maxAge the TTL of the value in cache\n * @returns the moizer function\n */\nmoize.maxAge = maxAge;\n\n/**\n * @function\n * @name maxArgs\n * @memberof module:moize\n * @alias moize.maxArgs\n *\n * @description\n * a moized method where the number of arguments used for determining cache is limited to the value passed\n *\n * @param maxArgs the number of args to base the key on\n * @returns the moizer function\n */\nmoize.maxArgs = function maxArgs(maxArgs: number) {\n    return moize({ maxArgs });\n};\n\n/**\n * @function\n * @name maxSize\n * @memberof module:moize\n * @alias moize.maxSize\n *\n * @description\n * a moized method where the total size of the cache is limited to the value passed\n *\n * @param maxSize the maximum size of the cache\n * @returns the moizer function\n */\nmoize.maxSize = function maxSize(maxSize: number) {\n    return moize({ maxSize });\n};\n\n/**\n * @function\n * @name profile\n * @memberof module:moize\n * @alias moize.profile\n *\n * @description\n * a moized method with a profile name\n *\n * @returns the moizer function\n */\nmoize.profile = function (profileName: string) {\n    return moize({ profileName });\n};\n\n/**\n * @function\n * @name promise\n * @memberof module:moize\n * @alias moize.promise\n *\n * @description\n * a moized method specific to caching resolved promise / async values\n *\n * @returns the moizer function\n */\nmoize.promise = moize({\n    isPromise: true,\n    updateExpire: true,\n});\n\n/**\n * @function\n * @name react\n * @memberof module:moize\n * @alias moize.react\n *\n * @description\n * a moized method specific to caching React element values\n *\n * @returns the moizer function\n */\nmoize.react = moize({ isReact: true });\n\n/**\n * @function\n * @name serialize\n * @memberof module:moize\n * @alias moize.serialize\n *\n * @description\n * a moized method that will serialize the arguments passed to use as the cache key\n *\n * @returns the moizer function\n */\nmoize.serialize = moize({ isSerialized: true });\n\n/**\n * @function\n * @name serializeWith\n * @memberof module:moize\n * @alias moize.serializeWith\n *\n * @description\n * a moized method that will serialize the arguments passed to use as the cache key\n * based on the serializer passed\n *\n * @returns the moizer function\n */\nmoize.serializeWith = function (serializer: Serialize) {\n    return moize({ isSerialized: true, serializer });\n};\n\n/**\n * @function\n * @name shallow\n * @memberof module:moize\n * @alias moize.shallow\n *\n * @description\n * should shallow equality check be used\n *\n * @returns the moizer function\n */\nmoize.shallow = moize({ isShallowEqual: true });\n\n/**\n * @function\n * @name transformArgs\n * @memberof module:moize\n * @alias moize.transformArgs\n *\n * @description\n * transform the args to allow for specific cache key comparison\n *\n * @param transformArgs the args transformer\n * @returns the moizer function\n */\nmoize.transformArgs = <Transformer extends TransformKey>(\n    transformArgs: Transformer\n) => moize({ transformArgs });\n\n/**\n * @function\n * @name updateCacheForKey\n * @memberof module:moize\n * @alias moize.updateCacheForKey\n *\n * @description\n * update the cache for a given key when the method passed returns truthy\n *\n * @param updateCacheForKey the method to determine when to update cache\n * @returns the moizer function\n */\nmoize.updateCacheForKey = <UpdateWhen extends UpdateCacheForKey>(\n    updateCacheForKey: UpdateWhen\n) => moize({ updateCacheForKey });\n\n// Add self-referring `default` property for edge-case cross-compatibility of mixed ESM/CommonJS usage.\n// This property is frozen and non-enumerable to avoid visibility on iteration or accidental overrides.\nObject.defineProperty(moize, 'default', {\n    configurable: false,\n    enumerable: false,\n    value: moize,\n    writable: false,\n});\n\nexport default moize;\n","import { copyStaticProperties } from './instance';\n\nimport type { Moized } from '../index.d';\n\nexport function createRefreshableMoized<MoizedFn extends Moized>(\n    moized: MoizedFn\n) {\n    const {\n        options: { updateCacheForKey },\n    } = moized;\n\n    /**\n     * @private\n     *\n     * @description\n     * Wrapper around already-`moize`d function which will intercept the memoization\n     * and call the underlying function directly with the purpose of updating the cache\n     * for the given key.\n     *\n     * Promise values use a tweak of the logic that exists at cache.updateAsyncCache, which\n     * reverts to the original value if the promise is rejected and there was already a cached\n     * value.\n     */\n    const refreshableMoized = function refreshableMoized(\n        this: any,\n        ...args: Parameters<typeof moized.fn>\n    ) {\n        if (!updateCacheForKey(args)) {\n            return moized.apply(this, args);\n        }\n\n        const result = moized.fn.apply(this, args);\n\n        moized.set(args, result);\n\n        return result;\n    } as typeof moized;\n\n    copyStaticProperties(moized, refreshableMoized);\n\n    return refreshableMoized;\n}\n"],"names":["DEFAULT_OPTIONS","isDeepEqual","isPromise","isReact","isSerialized","isShallowEqual","matchesArg","undefined","matchesKey","maxAge","maxArgs","maxSize","onExpire","profileName","serializer","updateCacheForKey","transformArgs","updateExpire","combine","_len","arguments","length","functions","Array","_key","reduce","f","g","apply","this","compose","_len2","_key2","findExpirationIndex","expirations","key","index","createFindKeyIndex","isEqual","isMatchingKey","areKeysEqual","cacheKey","keys","keysIndex","mergeOptions","originalOptions","newOptions","_extends","onCacheAdd","onCacheChange","onCacheHit","setName","fn","originalFunctionName","name","Object","defineProperty","configurable","enumerable","value","writable","_unused","clearExpiration","shouldRemove","expirationIndex","clearTimeout","timeoutId","splice","createTimeout","expirationMethod","setTimeout","unref","createOnCacheHitResetExpiration","options","cache","getMaxAgeOptions","isFinite","moizedOptions","moized","keyIndex","findKeyIndex","values","unshift","push","createOnCacheAddSetExpiration","statsCache","anonymousProfileNameCounter","isCollectingStats","profiles","hasWarningDisplayed","clearStats","createOnCacheAddIncrementCalls","calls","hits","createOnCacheHitIncrementCallsAndHits","getDefaultProfileName","displayName","getUsagePercentage","toFixed","getStats","console","warn","usage","profile","completeStats","completeProfiles","computedProfiles","ALWAYS_SKIPPED_PROPERTIES","callee","caller","constructor","prototype","copyStaticProperties","originalFn","newFn","skippedProperties","getOwnPropertyNames","forEach","property","indexOf","descriptor","getOwnPropertyDescriptor","get","set","createMoizeInstance","memoized","configuration","_ref","clear","_microMemoizeOptions","transformKey","has","cacheSnapshot","remove","_moized$_microMemoize","existingKey","cutoff","size","updateAsyncCache","orderByLru","addInstanceMethods","_ref2","moizeOptions","originalFunction","microMemoizeOptions","defineProperties","currentCache","slice","expirationsSnapshot","isMoized","addInstanceProperties","REACT_ELEMENT_TYPE","Symbol","for","getCutoff","array","getStringifiedArgument","arg","typeOfArg","JSON","stringify","type","toString","thisCutoff","valueCutoff","join","defaultArgumentSerializer","args","getIsSerializedKeyEqual","createOnCacheOperation","_cacheIgnored","_microMemoizeOptionsIgnored","getTransformKey","getSerializerFunction","clone","moize","passedOptions","moizeable","mergedOptions","curriedFn","curriedOptions","moizer","reactMoizer","Moized","props","context","updater","MoizedComponent","isReactComponent","render","$$typeof","ref","_owner","createMoizedComponent","coalescedOptions","customOptions","_objectWithoutPropertiesLoose","_excluded","deepEqual","shallowEqual","sameValueZeroEqual","getIsEqual","getIsMatchingKey","maxAgeOptions","statsOptions","getStatsOptions","memoize","refreshableMoized","result","createRefreshableMoized","collectStats","deep","infinite","Infinity","argMatcher","keyMatcher","expireOptions","promise","react","serialize","serializeWith","shallow"],"mappings":"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"}